<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>[HTB] vvm | üç† yamsbot</title>
<meta name="keywords" content="">
<meta name="description" content="
Description
&ldquo;Hard&rdquo; reversing challenge released about half a year ago at time of writing.
A new startup claims to have developed an unbreakable client-side password validation system. VCs have invested millions, but I&#39;m a bit skeptical of their claim. Can you prove them wrong?
Initial investigation
Before we begin static analysis we will run ltrace against the binary to see whats going on:
ltrace ./vvm
puts(&#34;=======================&#34;=======================
)                          = 24
puts(&#34;vvm v0.0.3&#34;vvm v0.0.3
)                                       = 11
puts(&#34;=======================&#34;=======================
)                          = 24
malloc(224)                                              = 0x61c7243906b0
mmap(0, 27, 7, 34)                                       = 0x71de16538000
mmap(0, 42, 7, 34)                                       = 0x71de164fe000
mmap(0, 25, 7, 34)                                       = 0x71de164fd000
mmap(0, 18, 7, 34)                                       = 0x71de164fc000
mmap(0, 56, 7, 34)                                       = 0x71de164fb000
mmap(0, 179, 7, 34)                                      = 0x71de164fa000
mmap(0, 37, 7, 34)                                       = 0x71de164f9000
mmap(0, 20, 7, 34)                                       = 0x71de164f8000
mmap(0, 59, 7, 34)                                       = 0x71de164f7000
mmap(0, 53, 7, 34)                                       = 0x71de164f6000
mmap(0, 40, 7, 34)                                       = 0x71de164f5000
mmap(0, 32, 7, 34)                                       = 0x71de164f4000
mmap(0, 20, 7, 34)                                       = 0x71de164f3000
mmap(0, 37, 7, 34)                                       = 0x71de164f2000
mmap(0, 50, 7, 34)                                       = 0x71de164f1000
mmap(0, 33, 7, 34)                                       = 0x71de164f0000
mmap(0, 37, 7, 34)                                       = 0x71de164ef000
mmap(0, 36, 7, 34)                                       = 0x71de164ee000
mmap(0, 21, 7, 34)                                       = 0x71de164ed000
mmap(0, 37, 7, 34)                                       = 0x71de164ec000
mmap(0, 36, 7, 34)                                       = 0x71de164eb000
mmap(0, 25, 7, 34)                                       = 0x71de164ea000
mmap(0, 27, 7, 34)                                       = 0x71de164e9000
mmap(0, 32, 7, 34)                                       = 0x71de164e8000
ptrace(0, 0, 0, 0)                                       = -1
exit(1 &lt;no return ...&gt;
&#43;&#43;&#43; exited (status 1) &#43;&#43;&#43;
The program allocates and maps a few memory regions, calls ptrace() and then exits. Based on experience we can confidently say that the ptrace() call is a simple anti-debugging measure. If the ptrace call returns a failure, the program is being debugged in some way and will exit. Based on this information we can start static analysis of the binary in Ghidra.">
<meta name="author" content="">
<link rel="canonical" href="https://yams.bot/writeups/hackthebox/vvm/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css" integrity="sha256-1vzSCk&#43;4bvpN&#43;sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://yams.bot/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://yams.bot/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://yams.bot/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://yams.bot/apple-touch-icon.png">
<link rel="mask-icon" href="https://yams.bot/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://yams.bot/writeups/hackthebox/vvm/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:url" content="https://yams.bot/writeups/hackthebox/vvm/">
  <meta property="og:site_name" content="üç† yamsbot">
  <meta property="og:title" content="[HTB] vvm">
  <meta property="og:description" content="
Description ‚ÄúHard‚Äù reversing challenge released about half a year ago at time of writing.
A new startup claims to have developed an unbreakable client-side password validation system. VCs have invested millions, but I&#39;m a bit skeptical of their claim. Can you prove them wrong?
Initial investigation Before we begin static analysis we will run ltrace against the binary to see whats going on:
ltrace ./vvm puts(&#34;=======================&#34;======================= ) = 24 puts(&#34;vvm v0.0.3&#34;vvm v0.0.3 ) = 11 puts(&#34;=======================&#34;======================= ) = 24 malloc(224) = 0x61c7243906b0 mmap(0, 27, 7, 34) = 0x71de16538000 mmap(0, 42, 7, 34) = 0x71de164fe000 mmap(0, 25, 7, 34) = 0x71de164fd000 mmap(0, 18, 7, 34) = 0x71de164fc000 mmap(0, 56, 7, 34) = 0x71de164fb000 mmap(0, 179, 7, 34) = 0x71de164fa000 mmap(0, 37, 7, 34) = 0x71de164f9000 mmap(0, 20, 7, 34) = 0x71de164f8000 mmap(0, 59, 7, 34) = 0x71de164f7000 mmap(0, 53, 7, 34) = 0x71de164f6000 mmap(0, 40, 7, 34) = 0x71de164f5000 mmap(0, 32, 7, 34) = 0x71de164f4000 mmap(0, 20, 7, 34) = 0x71de164f3000 mmap(0, 37, 7, 34) = 0x71de164f2000 mmap(0, 50, 7, 34) = 0x71de164f1000 mmap(0, 33, 7, 34) = 0x71de164f0000 mmap(0, 37, 7, 34) = 0x71de164ef000 mmap(0, 36, 7, 34) = 0x71de164ee000 mmap(0, 21, 7, 34) = 0x71de164ed000 mmap(0, 37, 7, 34) = 0x71de164ec000 mmap(0, 36, 7, 34) = 0x71de164eb000 mmap(0, 25, 7, 34) = 0x71de164ea000 mmap(0, 27, 7, 34) = 0x71de164e9000 mmap(0, 32, 7, 34) = 0x71de164e8000 ptrace(0, 0, 0, 0) = -1 exit(1 &lt;no return ...&gt; &#43;&#43;&#43; exited (status 1) &#43;&#43;&#43; The program allocates and maps a few memory regions, calls ptrace() and then exits. Based on experience we can confidently say that the ptrace() call is a simple anti-debugging measure. If the ptrace call returns a failure, the program is being debugged in some way and will exit. Based on this information we can start static analysis of the binary in Ghidra.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="writeups">
    <meta property="article:published_time" content="2025-01-24T03:00:11-05:00">
    <meta property="article:modified_time" content="2025-01-24T03:00:11-05:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[HTB] vvm">
<meta name="twitter:description" content="
Description
&ldquo;Hard&rdquo; reversing challenge released about half a year ago at time of writing.
A new startup claims to have developed an unbreakable client-side password validation system. VCs have invested millions, but I&#39;m a bit skeptical of their claim. Can you prove them wrong?
Initial investigation
Before we begin static analysis we will run ltrace against the binary to see whats going on:
ltrace ./vvm
puts(&#34;=======================&#34;=======================
)                          = 24
puts(&#34;vvm v0.0.3&#34;vvm v0.0.3
)                                       = 11
puts(&#34;=======================&#34;=======================
)                          = 24
malloc(224)                                              = 0x61c7243906b0
mmap(0, 27, 7, 34)                                       = 0x71de16538000
mmap(0, 42, 7, 34)                                       = 0x71de164fe000
mmap(0, 25, 7, 34)                                       = 0x71de164fd000
mmap(0, 18, 7, 34)                                       = 0x71de164fc000
mmap(0, 56, 7, 34)                                       = 0x71de164fb000
mmap(0, 179, 7, 34)                                      = 0x71de164fa000
mmap(0, 37, 7, 34)                                       = 0x71de164f9000
mmap(0, 20, 7, 34)                                       = 0x71de164f8000
mmap(0, 59, 7, 34)                                       = 0x71de164f7000
mmap(0, 53, 7, 34)                                       = 0x71de164f6000
mmap(0, 40, 7, 34)                                       = 0x71de164f5000
mmap(0, 32, 7, 34)                                       = 0x71de164f4000
mmap(0, 20, 7, 34)                                       = 0x71de164f3000
mmap(0, 37, 7, 34)                                       = 0x71de164f2000
mmap(0, 50, 7, 34)                                       = 0x71de164f1000
mmap(0, 33, 7, 34)                                       = 0x71de164f0000
mmap(0, 37, 7, 34)                                       = 0x71de164ef000
mmap(0, 36, 7, 34)                                       = 0x71de164ee000
mmap(0, 21, 7, 34)                                       = 0x71de164ed000
mmap(0, 37, 7, 34)                                       = 0x71de164ec000
mmap(0, 36, 7, 34)                                       = 0x71de164eb000
mmap(0, 25, 7, 34)                                       = 0x71de164ea000
mmap(0, 27, 7, 34)                                       = 0x71de164e9000
mmap(0, 32, 7, 34)                                       = 0x71de164e8000
ptrace(0, 0, 0, 0)                                       = -1
exit(1 &lt;no return ...&gt;
&#43;&#43;&#43; exited (status 1) &#43;&#43;&#43;
The program allocates and maps a few memory regions, calls ptrace() and then exits. Based on experience we can confidently say that the ptrace() call is a simple anti-debugging measure. If the ptrace call returns a failure, the program is being debugged in some way and will exit. Based on this information we can start static analysis of the binary in Ghidra.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "writeups",
      "item": "https://yams.bot/writeups/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "HackTheBox",
      "item": "https://yams.bot/writeups/hackthebox/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "[HTB] vvm",
      "item": "https://yams.bot/writeups/hackthebox/vvm/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "[HTB] vvm",
  "name": "[HTB] vvm",
  "description": "\nDescription \u0026ldquo;Hard\u0026rdquo; reversing challenge released about half a year ago at time of writing.\nA new startup claims to have developed an unbreakable client-side password validation system. VCs have invested millions, but I'm a bit skeptical of their claim. Can you prove them wrong?\nInitial investigation Before we begin static analysis we will run ltrace against the binary to see whats going on:\nltrace ./vvm puts(\u0026#34;=======================\u0026#34;======================= ) = 24 puts(\u0026#34;vvm v0.0.3\u0026#34;vvm v0.0.3 ) = 11 puts(\u0026#34;=======================\u0026#34;======================= ) = 24 malloc(224) = 0x61c7243906b0 mmap(0, 27, 7, 34) = 0x71de16538000 mmap(0, 42, 7, 34) = 0x71de164fe000 mmap(0, 25, 7, 34) = 0x71de164fd000 mmap(0, 18, 7, 34) = 0x71de164fc000 mmap(0, 56, 7, 34) = 0x71de164fb000 mmap(0, 179, 7, 34) = 0x71de164fa000 mmap(0, 37, 7, 34) = 0x71de164f9000 mmap(0, 20, 7, 34) = 0x71de164f8000 mmap(0, 59, 7, 34) = 0x71de164f7000 mmap(0, 53, 7, 34) = 0x71de164f6000 mmap(0, 40, 7, 34) = 0x71de164f5000 mmap(0, 32, 7, 34) = 0x71de164f4000 mmap(0, 20, 7, 34) = 0x71de164f3000 mmap(0, 37, 7, 34) = 0x71de164f2000 mmap(0, 50, 7, 34) = 0x71de164f1000 mmap(0, 33, 7, 34) = 0x71de164f0000 mmap(0, 37, 7, 34) = 0x71de164ef000 mmap(0, 36, 7, 34) = 0x71de164ee000 mmap(0, 21, 7, 34) = 0x71de164ed000 mmap(0, 37, 7, 34) = 0x71de164ec000 mmap(0, 36, 7, 34) = 0x71de164eb000 mmap(0, 25, 7, 34) = 0x71de164ea000 mmap(0, 27, 7, 34) = 0x71de164e9000 mmap(0, 32, 7, 34) = 0x71de164e8000 ptrace(0, 0, 0, 0) = -1 exit(1 \u0026lt;no return ...\u0026gt; +++ exited (status 1) +++ The program allocates and maps a few memory regions, calls ptrace() and then exits. Based on experience we can confidently say that the ptrace() call is a simple anti-debugging measure. If the ptrace call returns a failure, the program is being debugged in some way and will exit. Based on this information we can start static analysis of the binary in Ghidra.\n",
  "keywords": [
    
  ],
  "articleBody": "\nDescription ‚ÄúHard‚Äù reversing challenge released about half a year ago at time of writing.\nA new startup claims to have developed an unbreakable client-side password validation system. VCs have invested millions, but I'm a bit skeptical of their claim. Can you prove them wrong?\nInitial investigation Before we begin static analysis we will run ltrace against the binary to see whats going on:\nltrace ./vvm puts(\"=======================\"======================= ) = 24 puts(\"vvm v0.0.3\"vvm v0.0.3 ) = 11 puts(\"=======================\"======================= ) = 24 malloc(224) = 0x61c7243906b0 mmap(0, 27, 7, 34) = 0x71de16538000 mmap(0, 42, 7, 34) = 0x71de164fe000 mmap(0, 25, 7, 34) = 0x71de164fd000 mmap(0, 18, 7, 34) = 0x71de164fc000 mmap(0, 56, 7, 34) = 0x71de164fb000 mmap(0, 179, 7, 34) = 0x71de164fa000 mmap(0, 37, 7, 34) = 0x71de164f9000 mmap(0, 20, 7, 34) = 0x71de164f8000 mmap(0, 59, 7, 34) = 0x71de164f7000 mmap(0, 53, 7, 34) = 0x71de164f6000 mmap(0, 40, 7, 34) = 0x71de164f5000 mmap(0, 32, 7, 34) = 0x71de164f4000 mmap(0, 20, 7, 34) = 0x71de164f3000 mmap(0, 37, 7, 34) = 0x71de164f2000 mmap(0, 50, 7, 34) = 0x71de164f1000 mmap(0, 33, 7, 34) = 0x71de164f0000 mmap(0, 37, 7, 34) = 0x71de164ef000 mmap(0, 36, 7, 34) = 0x71de164ee000 mmap(0, 21, 7, 34) = 0x71de164ed000 mmap(0, 37, 7, 34) = 0x71de164ec000 mmap(0, 36, 7, 34) = 0x71de164eb000 mmap(0, 25, 7, 34) = 0x71de164ea000 mmap(0, 27, 7, 34) = 0x71de164e9000 mmap(0, 32, 7, 34) = 0x71de164e8000 ptrace(0, 0, 0, 0) = -1 exit(1 +++ exited (status 1) +++ The program allocates and maps a few memory regions, calls ptrace() and then exits. Based on experience we can confidently say that the ptrace() call is a simple anti-debugging measure. If the ptrace call returns a failure, the program is being debugged in some way and will exit. Based on this information we can start static analysis of the binary in Ghidra.\nStatic analysis No symbols of course, so lets navigate to entry and drop into the first argument. If you‚Äôre not familiar this will be main\nInside we see three functions:\nWe are going to ignore FUN_00102940(); as it calls puts() 3 times and returns. Dropping into FUN_00101540(); we can easily get overwhelmed. I wont attach a screenshot as there are over 780 lines in the decompilation. Reviewing this function we can identify that mmap() calls we observed from ltrace are called from this function. Further examination reveals that data is being decrypted and populated in these mapped regions.\nAt this point I am interested in what is being decrypted and populated in the mapped regions, so I wrote a small gnu debugger script that dumps the decrypted data out for us into files:\nset pagination off define dump_function python ipx = int(gdb.parse_and_eval(\"$ipx\")) addr = gdb.parse_and_eval(\"$addr_list[$ipx]\") len = gdb.parse_and_eval(\"$leng_list[$ipx]\") fn = f\"func_{ipx}\" gdb.execute(f\"dump memory {fn} {addr} {addr+len}\") end end starti break *$BASE+0x1198 break *$BASE+0x1191 c break mmap set $ipx = 0 set $addr_list = (long [24]) {0} set $leng_list = (int [24]) {0} c while ($ipx \u003c 24) set $len = $rsi finish set $addr_list[$ipx] = $rax set $leng_list[$ipx] = $len set $ipx=$ipx+1 c end set $ipx = 0 while ($ipx \u003c 24) dump_function set $ipx=$ipx+1 end In a gist, this script is setting a breakpoint each time that mmap() is called and extracting the length that was allocated and the address returned from mmap. Using the gdb python api we dump each mapped region to its own file.\nReviewing the dumped files, all of them start with a byte sequence that is equal to endbr64, signifying the start of a function. It‚Äôs safe to assume that each of these mapped regions contain a decrypted function that will later be called upon.\nUsing capstone we can disassemble these for further investigation:\n#!/usr/bin/env python3 import os from capstone import * l = sorted([int(x.split('_')[1]) for x in os.listdir(\"./functions\")]) for f in l: with open(f\"./functions/func_{f}\", \"rb\") as _f: CODE = _f.read() _f.close() print(f\"======= func_{f} =======\") md = Cs(CS_ARCH_X86, CS_MODE_64) for i in md.disasm(CODE,0x00): print(\"0x%x:\\t%s\\t%s\" %(i.address, i.mnemonic, i.op_str)) print() These functions are good to note, but currently by themselves they don‚Äôt help us out too much.\nMoving into FUN_001028a0();, this looks suspiciously similar to virtual machine execution loops I have seen in the past.\nAt this point in time we know:\nFunctions are being decrypted in stored in memory A virtual machine execution loop The next step is to find the actual vm code that is executed. This is pretty easy to identify, as we have the addresses right in front of us.\niVar2 = DAT_00105560;\nNavigating to DAT_00105560 in Ghidra we see a large amount of ‚Äúrandom‚Äù bytes. Hint: these representinstructions and arguments\nIn this image we also identify how the functions are called in the execution loop.\nif (instruction != 0x1c) { do { (**(code **)(jmp_table + (long)instruction * 8)) (\u0026instruction,\u0026local_38,\u0026DAT_001063a0,\u0026DAT_00106380); piVar1 = local_38 + 1; instruction = *local_38; local_38 = piVar1; } while (instruction != 0x1c); } I‚Äôve modified the above snippet slightly to give you an idea of how the functions are called. There is a jump table address used as a base, the instruction value is multiplied by 0x8, the result is added to the jump table address and the function is then called. Hopefully that makes sense.\nAt this point we have done as much static analysis as we can, or that I‚Äôd like to.\nDynamic analysis Sparing you from all of the testing and verifying done in the dynamic stage of analysis, overtime I built out a gdb script to automate the analysis of the program. Due to the size, I will include the scripts used at the bottom of the writeup.\nI broke the program down into sections based on ‚Äúexecution loops‚Äù. Function 0x11, when called, behaves similar to the higher level execution loop, but performs some additional steps including instruction pointer and rcx manipulation. In this case, I counted every execution of a vm function as an execution loop:\n000 - 071: strings setup 072: ptrace() call 073 - 098: strings setup and user input preparation 099: print string and read user input 100 - 102: calculate size of user input 103 - 120: math on user input length, generate compare value, check compare At this point, if the length of the password (with math applied) you entered does not equal the calculated value, the program will begin to build another string. If the values do match, the program continues with normal execution flow.\n121 - 284: disorganizes password input, example: ABCD -\u003e CABD 285 - 491: math against disorganized password 492: perform and operation against a post-math operation value At this point, if the AND operation does not return 0, the program will begin to build a string, print it and exit. If the AND operation does return 0, the program will continue with normal execution. It does not serve much purpose, the rest of the program performs the same action as execution loop 492, and the end result will print out a string ‚ÄúIncorrect :(‚Äù or ‚ÄúCorrect!‚Äù based on the results.\nMy approach There are a few different ways you can go about this. The easiest way would be to reverse the math operations used against the password input. You need to identify the order the password was scrambled in, and the math applied to each section. You can reverse this process by hand to find the compare values, or you can use z3. I used z3.\nFor fun, I also scripted out my own emulation of the program. To do this I took the instructions from the program, diassembled each function call and implemented the functions in my emulator.\nAnyways, below is my emulator and my gdb analysis script. Enjoy!\nI left out some crucial parts of this program as to not feed you the flag Also note I am no computer scientist, I wrote this program on the fly with no optimization or anything in mind, just wanted a working emulator so I could see everything from a higher level.\nemulator.py #!/usr/bin/env python3 import z3 instructions = [\"add your own instructions :P\"] class colors: HEADER = '\\033[95m' OKBLUE = '\\033[94m' OKCYAN = '\\033[96m' OKGREEN = '\\033[92m' WARNING = '\\033[93m' FAIL = '\\033[91m' ENDC = '\\033[0m' BOLD = '\\033[1m' UNDERLINE = '\\033[4m' def parser(_list, password, _length): sb = [bytearray(8) for _x_ in range(32)] rcx = oi = i = loop = 0 password_indexes = [] subloop = False while i \u003c= _length: #print_zone(sb, rcx) #print() try: v = _list[i][3] except Exception: print(\"No more instructions!\") return password_indexes match v: case 0x00: # gets size of user input print(f\"{loop} [FN 0x00]: size of input calculated\\tRCX = {rcx}\") sb[1] = bytearray(len(password).to_bytes(8, \"big\")) i += 1 case 0x01: # shl print(f\"{loop} [FN 0x01]: \", end=\"\") print(f\"0x{int.from_bytes(sb[rcx-2], 'big'):016X} \u003c\u003c 0x{int.from_bytes(sb[rcx-1], 'big'):02x}\") sb[rcx-2] = bytearray(int((int.from_bytes(sb[rcx-2], \"big\") \u003c\u003c int.from_bytes(sb[rcx-1], \"big\")) \u0026 0xffffffff).to_bytes(8, \"big\")) rcx -= 1 i += 1 case 0x02: # modulus print(f\"{loop} [FN 0x02]: \", end=\"\") print(f\"0x{int.from_bytes(sb[rcx-2], 'big'):016X} % 0x{int.from_bytes(sb[rcx-1], 'big'):02x}\") sb[rcx-2][-1] = sb[rcx-2][-1] % sb[rcx-1][-1] rcx -= 1 i += 1 case 0x03: # userinput # to simulate what the vm is doing, lets set ba[0] to a \"ptr\" sb[0] = bytearray(int(0x000055555555c860).to_bytes(8, \"big\")) rcx += 1 i += 2 case 0x04: # idiv print(f\"{loop} [FN 0x04]: \", end=\"\") print(f\"0x{int.from_bytes(sb[rcx-2], 'big'):016X} / 0x{int.from_bytes(sb[rcx-1], 'big'):02x}\") sb[rcx-2] = bytearray(idiv_func(int.from_bytes(sb[rcx-2], \"big\"), int.from_bytes(sb[rcx-1], \"big\")).to_bytes(8, \"big\")) rcx -= 1 i += 1 case 0x05: # add print(f\"{loop} [FN 0x05]: \", end=\"\") print(f\"0x{int.from_bytes(sb[rcx-2], 'big'):016X} + 0x{int.from_bytes(sb[rcx-1], 'big'):02x}\") sb[rcx-2] = bytearray((int.from_bytes(sb[rcx-2], \"big\")+int.from_bytes(sb[rcx-1], \"big\")).to_bytes(8, \"big\")) rcx -= 1 i += 1 case 0x06: # imul print(f\"{loop} [FN 0x05]: \", end=\"\") print(f\"0x{int.from_bytes(sb[rcx-2], 'big'):016X} * 0x{int.from_bytes(sb[rcx-1], 'big'):02x}\") sb[rcx-2] = bytearray(imul_func(int.from_bytes(sb[rcx-2], \"big\"), int.from_bytes(sb[rcx-1], \"big\")).to_bytes(8, \"big\")) rcx -= 1 i += 1 case 0x07: # ptrace wrapper print(f\"{loop} [FN 0x07]: {colors.WARNING}ptrace() call{colors.ENDC}\\tRCX = {rcx}\") i += 1 case 0x08: print(f\"{loop} [FN 0x08]: 0x08\\tRCX = {rcx}\") sb[rcx-2] = bytearray(int(int.from_bytes(sb[rcx-2], \"big\")|int.from_bytes(sb[rcx-1], \"big\")).to_bytes(8, \"big\")) rcx -= 1 i += 1 case 0x09: # more math print(f\"{loop} [FN 0x09]: silly maths\\tRCX = {rcx}\") if sb[rcx-1][-2] != 0: rax = (sb[rcx-1][-2] \u003c\u003c 8) + sb[rcx-1][-1] rax += 0x11 else: rax = sb[rcx-1][-1] + 0x11 _rcx = rax rdx = 0x5555555555555556 rdx = (rdx * rax) \u003e\u003e 64 rax = rax \u003e\u003e 0x3f rdx -= rax rax = rdx+rdx*2 sb[rcx-1][-1] = _rcx - rax i += 1 case 0x0a: # print_chk, free print(f\"{loop} [FN 0x0a]: print\\tRCX = {rcx}\") _out = \"\" for vv in sb: if vv[-1] != 0x0 and vv[-1] != 0x0a: _out += chr(vv[-1]) else: break print(f\"{colors.OKGREEN}[TXT]: \\\"{_out}\\\"{colors.ENDC}\") rcx -= 1 i += 1 case 0x0b: # jmp s = _list[i+1][3] i += s+1 print(f\"{loop} [FN 0x0b]: jmp $rip+{hex(s)}\\tRCX = {rcx}\") case 0x0c: # math print(f\"{loop} [FN 0x0c]: silly maths\\tRCX = {rcx}\") rax = sb[rcx-1][-1] rax = rax+rax*2-0x06 rax += rax if rax \u003e 0xff: sb[rcx-1][-1] = rax \u0026 0xff sb[rcx-1][-2] = rax \u003e\u003e 8 else: sb[rcx-1][-1] = rax i += 1 case 0x0d: # looping over password print(f\"{loop} [FN 0x0d]: password loop\\tRCX = {rcx}\") rcx = 1 i += 1 case 0x0e: # zero out chunk print(f\"{loop} [FN 0x0e]: zero out chunk\\tRCX = {rcx}\") sb[rcx-1] = bytearray((0).to_bytes(8, \"big\")) rcx -= 1 i += 1 case 0x0f: # malloc to prep for user input print(f\"{loop} [FN 0x0f]: prep for user input\\tRCX = {rcx}\") rcx = 1 i += 2 case 0x10: # copy one 8 byte chunk to another print(f\"{loop} [FN 0x10]: \\tRCX = {rcx}\") _val = _list[i+1][3] _rcx = rcx-0x1 _rcx -= _val sb[rcx] = sb[_rcx] #check rcx += 1 i += 2 case 0x11: # internal loop, ensure this works subloop = True oi = i + 3 _st = _list[i+2][3] jmp_cond = _list[i+1][3] + (_list[i+2][0] \u003c\u003c 8) # sry print(f\"{loop} [FN 0x11]: next = {hex(jmp_cond)}\\tRCX = {rcx}\") i = jmp_cond case 0x12: # grab random char from user input _loc = _list[i+1][3] print(f\"{loop} [FN 0x12] password[{_loc}]: {chr(password[_loc])}\\tRCX = {rcx}\") password_indexes.append(_loc) _val = password[_loc] sb[rcx-1] = bytearray(int(_val).to_bytes(8, \"big\")) i += 2 case 0x13: # compare computed sizes print(f\"{loop} [FN 0x13]: \", end=\"\") print(f\"0x{int.from_bytes(sb[rcx-2], 'big'):016X} == 0x{int.from_bytes(sb[rcx-1], 'big'):02x}\") if sb[rcx-2] == sb[rcx-1]: print(f\"{colors.OKGREEN}true{colors.ENDC}\") sb[rcx-2] = bytearray((1).to_bytes(8, \"big\")) else: print(f\"{colors.FAIL}false{colors.ENDC}\") sb[rcx-2] = bytearray((0).to_bytes(8, \"big\")) rcx -= 1 i += 1 case 0x14: print(f\"{colors.FAIL}! [FN 0x14] !{colors.ENDC}\") rcx -= 1 i += 1 case 0x15: # math, this might need to be fixed idk print(f\"{loop} [FN 0x15]: silly maths\\tRCX = {rcx}\") rdx = sb[rcx-1][-1] rdx = (rdx * 8) + 0x18 if rdx \u003e 0xff: sb[rcx-1][-1] = rdx \u0026 0xff sb[rcx-1][-2] = rdx \u003e\u003e 8 else: sb[rcx-1][-1] = rdx i += 1 case 0x16: # check compare result, jmp accordingly print(f\"{loop} [FN 0x16]: \", end=\"\") print(f\"0x{int.from_bytes(sb[rcx-1], 'big'):016x} \u0026 0x{int.from_bytes(sb[rcx-1], 'big'):02x}\") _tmp = int.from_bytes(sb[rcx-1], \"big\") _tmp = _tmp \u0026 _tmp if _tmp != 0: print(f\"adding {_list[i+1][3]} to instruction pointer\") i += int.from_bytes(_list[i+1], \"big\") i += 2 rcx -= 1 case 0x17: # relative move print(f\"{loop} [FN 0x17]: mov sb[{rcx}], 0x{int.from_bytes(sb[rcx-1], 'big'):016x}\\tRCX = {rcx}\") sb[rcx] = bytearray(int.from_bytes(sb[rcx-1], \"big\").to_bytes(8, \"big\")) rcx += 1 i += 1 case 0x18: # sub print(f\"{loop} [FN 0x18]: \", end=\"\") print(f\"0x{int.from_bytes(sb[rcx-2], 'big'):016X} -= 0x{int.from_bytes(sb[rcx-1], 'big'):02x}\") try: sb[rcx-2] = bytearray((int.from_bytes(sb[rcx-2], \"big\") - int.from_bytes(sb[rcx-1], \"big\") \u0026 (4**32-1)).to_bytes(8, \"big\")) except Exception as e: print(f\"{colors.FAIL}[!] {e}{colors.ENDC}\\nExiting..\\n\") print(sb[rcx-2], sb[rcx-1]) exit(1) rcx -= 1 i += 1 case 0x19: # immediate move print(f\"{loop} [FN 0x19]: imm sb[{rcx}], {hex(_list[i+1][3] + (_list[i+2][0] \u003c\u003c 8) + (_list[i+2][1] \u003c\u003c 16))}\") sb[rcx] = bytearray((_list[i+1][3] + (_list[i+2][0] \u003c\u003c 8) + (_list[i+2][1] \u003c\u003c 16)).to_bytes(8, \"big\")) rcx += 1 i += 2 case 0x1a: #shr print(f\"{loop} [FN 0x1a] \", end=\"\") print(f\"0x{int.from_bytes(sb[rcx-2], 'big'):016X} \u003e\u003e 0x{int.from_bytes(sb[rcx-1], 'big'):02x}\") sb[rcx-2] = bytearray(int((int.from_bytes(sb[rcx-2], \"big\") \u003e\u003e int.from_bytes(sb[rcx-1], \"big\")) \u0026 0xffffffff).to_bytes(8, \"big\")) rcx -= 1 i += 1 case 0x1c: if subloop: _val = sb[rcx-1] _rcx = rcx - _st - 1 sb[_rcx] = bytearray(int.from_bytes(_val, \"big\").to_bytes(8, \"big\")) rcx -= _st i = oi print(f\"{loop} [FN 0x1c] restore ip\\tRCX = {rcx}\") subloop = False continue else: print(f\"{loop} [FN 0x1c] EXIT\") return password_indexes case _: print(f\"{colors.FAIL}Hit an invalid instruction!!! [{hex(v)}]{colors.ENDC}\") exit() loop += 1 #print_zone(sb, rcx) #print() def print_zone(zone, rcx, i = 0): while i \u003c len(zone): if i == rcx-2: print(f\"{colors.OKCYAN}\", end=\"\") elif i == rcx-1: print(f\"{colors.OKGREEN}\", end=\"\") if i == 0 or i % 2 == 0: print(f\"0x{int.from_bytes(zone[i], 'big'):016x}\", end=\"\\t\") else: print(f\"0x{int.from_bytes(zone[i], 'big'):016x}\") print(f\"{colors.ENDC}\", end=\"\") i += 1 def imul_func(a, b): return int(a * b) def idiv_func(a, b): return int(a / b) def split_instructions(): count = 0 split_inst = [] cur = b\"\" for v in instructions: if count % 4 == 0 and count != 0: split_inst.append(cur) cur = v.to_bytes(1, \"little\") else: cur += v.to_bytes(1, \"little\") count += 1 return split_inst def more_fun(pw_index, password): pwd = [bytearray(b\"\\x00\" * 8) for i in range(8)] print(\"pw_index\") print(pw_index) c = d = 0 for i in range(0, len(pw_index)): if i % 4 != 0 or i == 0: pwd[c][~d] = password[pw_index[i]] d += 1 else: c += 1 d = 0 pwd[c][~d] = password[pw_index[i]] d += 1 i += 1 print(\"\\n[+] initial sorted password chunks\") for v in pwd: print(f\"0x{int.from_bytes(v, 'big'):016x}\") andv = 4**16-1 for i in range(7, ~0, -1): a = int.from_bytes(pwd[i], \"big\") match i: case 7: [redacted] case 6: [redacted] case 5: [redacted] case 4: [redacted] case 3: [redacted] case 2: [redacted] case 1: [redacted] case 0: [redacted] print(f\"chunk {i}: 0x{z \u0026 4**32-1:016x}\") if (z \u0026 z) == 0: print(f\"{colors.OKGREEN}match{colors.ENDC}\") else: print(f\"{colors.FAIL}!match{colors.ENDC}\") def gen_password(pw_index): # add yourself! pass def runner(password): _list = split_instructions() #print(_list) pw_index = parser(_list, password, len(_list)) more_fun(pw_index, password) #gen_password(pw_index) def main(): runner(b\"\") if __name__ == \"__main__\": main() analysis.gdb set pagination off set confirm off starti display/x $rax display/x $rdi display/x $rsi display/x $rdx display/x $rcx display/x $r8 display/x $r9 display/x $rsp display/x $rbp display/10i $rip set $str=0x55555555a3a0 set $ins=0x7fffffffdea0 set $analysisBp = 400 # break at call to execution loop break *$base+0x1198 c # ptrace break break *$base+0x13f7 commands set $rax=0x0 c end # break at each iteration of loop to identify which function is called set $loop=0 break *$base+0x2908 commands silent printf \"loop: %d\\n\", $loop printf \"call qword ptr [R8+R9*0x8] = 0x%llx\\n\", $r8+($r9*8) printf \"function = 0x%llx\\n\", *(long *)($r8+($r9*8)) printf \"[func] = 0x%lx\\n\", $r9 printf \"rcx = 0x%lx\\n\", *(long *)$rcx printf \"inst: 0x%lx\\n\\n\", *(long *)$ins set $loop=$loop+1 if $loop \u003c= $analysisBp c end end # break inside of 0x11 function loop break *0x00007ffff7fb6069 commands printf \"loop: %d\\n\", $loop printf \"[func] = 0x%lx\\n\", $r9 printf \"rcx = 0x%lx\\n\", *(long *)$rcx set $loop=$loop+1 end # start c ",
  "wordCount" : "2688",
  "inLanguage": "en",
  "datePublished": "2025-01-24T03:00:11-05:00",
  "dateModified": "2025-01-24T03:00:11-05:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://yams.bot/writeups/hackthebox/vvm/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "üç† yamsbot",
    "logo": {
      "@type": "ImageObject",
      "url": "https://yams.bot/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://yams.bot/" accesskey="h" title="üç† yamsbot (Alt + H)">üç† yamsbot</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://yams.bot/about/" title="about">
                    <span>about</span>
                </a>
            </li>
            <li>
                <a href="https://yams.bot/writeups/" title="writeups">
                    <span>writeups</span>
                </a>
            </li>
            <li>
                <a href="https://yams.bot/research/" title="research">
                    <span>research</span>
                </a>
            </li>
            <li>
                <a href="https://yams.bot/random/" title="random">
                    <span>random</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      [HTB] vvm
    </h1>
    <div class="post-meta"><span title='2025-01-24 03:00:11 -0500 EST'>January 24, 2025</span>&nbsp;¬∑&nbsp;13 min&nbsp;¬∑&nbsp;2688 words

</div>
  </header> 
  <div class="post-content"><p><img loading="lazy" src="/images/hackthebox/vvm/banner.png"></p>
<h2 id="description">Description<a hidden class="anchor" aria-hidden="true" href="#description">#</a></h2>
<p>&ldquo;Hard&rdquo; reversing challenge released about half a year ago at time of writing.</p>
<p><code>A new startup claims to have developed an unbreakable client-side password validation system. VCs have invested millions, but I'm a bit skeptical of their claim. Can you prove them wrong?</code></p>
<h2 id="initial-investigation">Initial investigation<a hidden class="anchor" aria-hidden="true" href="#initial-investigation">#</a></h2>
<p>Before we begin static analysis we will run ltrace against the binary to see whats going on:</p>
<pre tabindex="0"><code>ltrace ./vvm
puts(&#34;=======================&#34;=======================
)                          = 24
puts(&#34;vvm v0.0.3&#34;vvm v0.0.3
)                                       = 11
puts(&#34;=======================&#34;=======================
)                          = 24
malloc(224)                                              = 0x61c7243906b0
mmap(0, 27, 7, 34)                                       = 0x71de16538000
mmap(0, 42, 7, 34)                                       = 0x71de164fe000
mmap(0, 25, 7, 34)                                       = 0x71de164fd000
mmap(0, 18, 7, 34)                                       = 0x71de164fc000
mmap(0, 56, 7, 34)                                       = 0x71de164fb000
mmap(0, 179, 7, 34)                                      = 0x71de164fa000
mmap(0, 37, 7, 34)                                       = 0x71de164f9000
mmap(0, 20, 7, 34)                                       = 0x71de164f8000
mmap(0, 59, 7, 34)                                       = 0x71de164f7000
mmap(0, 53, 7, 34)                                       = 0x71de164f6000
mmap(0, 40, 7, 34)                                       = 0x71de164f5000
mmap(0, 32, 7, 34)                                       = 0x71de164f4000
mmap(0, 20, 7, 34)                                       = 0x71de164f3000
mmap(0, 37, 7, 34)                                       = 0x71de164f2000
mmap(0, 50, 7, 34)                                       = 0x71de164f1000
mmap(0, 33, 7, 34)                                       = 0x71de164f0000
mmap(0, 37, 7, 34)                                       = 0x71de164ef000
mmap(0, 36, 7, 34)                                       = 0x71de164ee000
mmap(0, 21, 7, 34)                                       = 0x71de164ed000
mmap(0, 37, 7, 34)                                       = 0x71de164ec000
mmap(0, 36, 7, 34)                                       = 0x71de164eb000
mmap(0, 25, 7, 34)                                       = 0x71de164ea000
mmap(0, 27, 7, 34)                                       = 0x71de164e9000
mmap(0, 32, 7, 34)                                       = 0x71de164e8000
ptrace(0, 0, 0, 0)                                       = -1
exit(1 &lt;no return ...&gt;
+++ exited (status 1) +++
</code></pre><p>The program allocates and maps a few memory regions, calls <code>ptrace()</code> and then exits. Based on experience we can confidently say that the <code>ptrace()</code> call is a simple anti-debugging measure. If the ptrace call returns a failure, the program is being debugged in some way and will exit. Based on this information we can start static analysis of the binary in Ghidra.</p>
<h2 id="static-analysis">Static analysis<a hidden class="anchor" aria-hidden="true" href="#static-analysis">#</a></h2>
<p>No symbols of course, so lets navigate to <code>entry</code> and drop into the first argument. If you&rsquo;re not familiar this will be <code>main</code></p>
<p><img loading="lazy" src="/images/hackthebox/vvm/entry.png"></p>
<p>Inside we see three functions:</p>
<p><img loading="lazy" src="/images/hackthebox/vvm/main.png"></p>
<p>We are going to ignore <code>FUN_00102940();</code> as it calls <code>puts()</code> 3 times and returns. Dropping into <code>FUN_00101540();</code> we can easily get overwhelmed. I wont attach a screenshot as there are over 780 lines in the decompilation. Reviewing this function we can identify that <code>mmap()</code> calls we observed from <code>ltrace</code> are called from this function. Further examination reveals that data is being decrypted and populated in these mapped regions.</p>
<p>At this point I am interested in what is being decrypted and populated in the mapped regions, so I wrote a small gnu debugger script that dumps the decrypted data out for us into files:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>set pagination off
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>define dump_function
</span></span><span style="display:flex;"><span>python
</span></span><span style="display:flex;"><span>ipx = int(gdb.parse_and_eval(&#34;$ipx&#34;))
</span></span><span style="display:flex;"><span>addr = gdb.parse_and_eval(&#34;$addr_list[$ipx]&#34;)
</span></span><span style="display:flex;"><span>len = gdb.parse_and_eval(&#34;$leng_list[$ipx]&#34;)
</span></span><span style="display:flex;"><span>fn = f&#34;func_{ipx}&#34;
</span></span><span style="display:flex;"><span>gdb.execute(f&#34;dump memory {fn} {addr} {addr+len}&#34;)
</span></span><span style="display:flex;"><span>end
</span></span><span style="display:flex;"><span>end
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>starti
</span></span><span style="display:flex;"><span>break *$BASE+0x1198
</span></span><span style="display:flex;"><span>break *$BASE+0x1191
</span></span><span style="display:flex;"><span>c
</span></span><span style="display:flex;"><span>break mmap
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>set $ipx = 0
</span></span><span style="display:flex;"><span>set $addr_list = (long [24]) {0}
</span></span><span style="display:flex;"><span>set $leng_list = (int [24]) {0}
</span></span><span style="display:flex;"><span>c
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>while ($ipx &lt; 24)
</span></span><span style="display:flex;"><span>    set $len = $rsi
</span></span><span style="display:flex;"><span>    finish
</span></span><span style="display:flex;"><span>    set $addr_list[$ipx] = $rax
</span></span><span style="display:flex;"><span>    set $leng_list[$ipx] = $len
</span></span><span style="display:flex;"><span>    set $ipx=$ipx+1
</span></span><span style="display:flex;"><span>    c
</span></span><span style="display:flex;"><span>end
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>set $ipx = 0
</span></span><span style="display:flex;"><span>while ($ipx &lt; 24)
</span></span><span style="display:flex;"><span>    dump_function
</span></span><span style="display:flex;"><span>    set $ipx=$ipx+1
</span></span><span style="display:flex;"><span>end
</span></span></code></pre></div><p>In a gist, this script is setting a breakpoint each time that <code>mmap()</code> is called and extracting the length that was allocated and the address returned from mmap. Using the gdb python api we dump each mapped region to its own file.</p>
<p>Reviewing the dumped files, all of them start with a byte sequence that is equal to <code>endbr64</code>, signifying the start of a function. It&rsquo;s safe to assume that each of these mapped regions contain a decrypted function that will later be called upon.</p>
<p>Using capstone we can disassemble these for further investigation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python3" data-lang="python3"><span style="display:flex;"><span><span style="color:#75715e">#!/usr/bin/env python3</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> os
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> capstone <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l <span style="color:#f92672">=</span> sorted([int(x<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;_&#39;</span>)[<span style="color:#ae81ff">1</span>]) <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> os<span style="color:#f92672">.</span>listdir(<span style="color:#e6db74">&#34;./functions&#34;</span>)])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> f <span style="color:#f92672">in</span> l:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;./functions/func_</span><span style="color:#e6db74">{</span>f<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>, <span style="color:#e6db74">&#34;rb&#34;</span>) <span style="color:#66d9ef">as</span> _f:
</span></span><span style="display:flex;"><span>        CODE <span style="color:#f92672">=</span> _f<span style="color:#f92672">.</span>read()
</span></span><span style="display:flex;"><span>        _f<span style="color:#f92672">.</span>close()
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;======= func_</span><span style="color:#e6db74">{</span>f<span style="color:#e6db74">}</span><span style="color:#e6db74"> =======&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    md <span style="color:#f92672">=</span> Cs(CS_ARCH_X86, CS_MODE_64)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> md<span style="color:#f92672">.</span>disasm(CODE,<span style="color:#ae81ff">0x00</span>):
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">:</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">%s</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span>(i<span style="color:#f92672">.</span>address, i<span style="color:#f92672">.</span>mnemonic, i<span style="color:#f92672">.</span>op_str))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    print()
</span></span></code></pre></div><p>These functions are good to note, but currently by themselves they don&rsquo;t help us out too much.</p>
<p>Moving into <code>FUN_001028a0();</code>, this looks suspiciously similar to virtual machine execution loops I have seen in the past.</p>
<p><img loading="lazy" src="/images/hackthebox/vvm/vm_loop.png"></p>
<p>At this point in time we know:</p>
<ul>
<li>Functions are being decrypted in stored in memory</li>
<li>A virtual machine execution loop</li>
</ul>
<p>The next step is to find the actual vm code that is executed. This is pretty easy to identify, as we have the addresses right in front of us.</p>
<p><img loading="lazy" src="/images/hackthebox/vvm/vm_loop_edit.png"></p>
<p><code>iVar2 = DAT_00105560;</code></p>
<p>Navigating to <code>DAT_00105560</code> in Ghidra we see a large amount of &ldquo;random&rdquo; bytes. Hint: these representinstructions and arguments</p>
<p>In this image we also identify how the functions are called in the execution loop.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (instruction <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0x1c</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>      (<span style="color:#f92672">**</span>(code <span style="color:#f92672">**</span>)(jmp_table <span style="color:#f92672">+</span> (<span style="color:#66d9ef">long</span>)instruction <span style="color:#f92672">*</span> <span style="color:#ae81ff">8</span>))
</span></span><span style="display:flex;"><span>                (<span style="color:#f92672">&amp;</span>instruction,<span style="color:#f92672">&amp;</span>local_38,<span style="color:#f92672">&amp;</span>DAT_001063a0,<span style="color:#f92672">&amp;</span>DAT_00106380);
</span></span><span style="display:flex;"><span>      piVar1 <span style="color:#f92672">=</span> local_38 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>      instruction <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>local_38;
</span></span><span style="display:flex;"><span>      local_38 <span style="color:#f92672">=</span> piVar1;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">while</span> (instruction <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0x1c</span>);
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>I&rsquo;ve modified the above snippet slightly to give you an idea of how the functions are called. There is a jump table address used as a base, the instruction value is multiplied by 0x8, the result is added to the jump table address and the function is then called. Hopefully that makes sense.</p>
<p>At this point we have done as much static analysis as we can, or that I&rsquo;d like to.</p>
<h2 id="dynamic-analysis">Dynamic analysis<a hidden class="anchor" aria-hidden="true" href="#dynamic-analysis">#</a></h2>
<p>Sparing you from all of the testing and verifying done in the dynamic stage of analysis, overtime I built out a gdb script to automate the analysis of the program. Due to the size, I will include the scripts used at the bottom of the writeup.</p>
<p>I broke the program down into sections based on &ldquo;execution loops&rdquo;. Function 0x11, when called, behaves similar to the higher level execution loop, but performs some additional steps including instruction pointer and rcx manipulation. In this case, I counted every execution of a vm function as an execution loop:</p>
<pre tabindex="0"><code>000 - 071: strings setup
      072: ptrace() call
073 - 098: strings setup and user input preparation
      099: print string and read user input
100 - 102: calculate size of user input
103 - 120: math on user input length, generate compare value, check compare
</code></pre><p>At this point, if the length of the password (with math applied) you entered does not equal the calculated value, the program will begin to build another string. If the values do match, the program continues with normal execution flow.</p>
<pre tabindex="0"><code>121 - 284: disorganizes password input, example: ABCD -&gt; CABD
285 - 491: math against disorganized password
      492: perform and operation against a post-math operation value
</code></pre><p>At this point, if the AND operation does not return 0, the program will begin to build a string, print it and exit. If the AND operation does return 0, the program will continue with normal execution. It does not serve much purpose, the rest of the program performs the same action as execution loop 492, and the end result will print out a string &ldquo;Incorrect :(&rdquo; or &ldquo;Correct!&rdquo; based on the results.</p>
<h3 id="my-approach">My approach<a hidden class="anchor" aria-hidden="true" href="#my-approach">#</a></h3>
<p>There are a few different ways you can go about this. The easiest way would be to reverse the math operations used against the password input. You need to identify the order the password was scrambled in, and the math applied to each section. You can reverse this process by hand to find the compare values, or you can use z3. I used z3.</p>
<p>For fun, I also scripted out my own emulation of the program. To do this I took the instructions from the program, diassembled each function call and implemented the functions in my emulator.</p>
<p>Anyways, below is my emulator and my gdb analysis script. Enjoy!</p>
<p><img loading="lazy" src="/images/hackthebox/vvm/emu_flag.png"></p>
<p><strong>I left out some crucial parts of this program as to not feed you the flag
Also note I am no computer scientist, I wrote this program on the fly with no optimization or anything in mind, just wanted a working emulator so I could see everything from a higher level.</strong></p>
<h4 id="emulatorpy">emulator.py<a hidden class="anchor" aria-hidden="true" href="#emulatorpy">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python3" data-lang="python3"><span style="display:flex;"><span><span style="color:#75715e">#!/usr/bin/env python3</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> z3
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>instructions <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;add your own instructions :P&#34;</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">colors</span>:
</span></span><span style="display:flex;"><span>    HEADER <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\033</span><span style="color:#e6db74">[95m&#39;</span>
</span></span><span style="display:flex;"><span>    OKBLUE <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\033</span><span style="color:#e6db74">[94m&#39;</span>
</span></span><span style="display:flex;"><span>    OKCYAN <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\033</span><span style="color:#e6db74">[96m&#39;</span>
</span></span><span style="display:flex;"><span>    OKGREEN <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\033</span><span style="color:#e6db74">[92m&#39;</span>
</span></span><span style="display:flex;"><span>    WARNING <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\033</span><span style="color:#e6db74">[93m&#39;</span>
</span></span><span style="display:flex;"><span>    FAIL <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\033</span><span style="color:#e6db74">[91m&#39;</span>
</span></span><span style="display:flex;"><span>    ENDC <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\033</span><span style="color:#e6db74">[0m&#39;</span>
</span></span><span style="display:flex;"><span>    BOLD <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\033</span><span style="color:#e6db74">[1m&#39;</span>
</span></span><span style="display:flex;"><span>    UNDERLINE <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\033</span><span style="color:#e6db74">[4m&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">parser</span>(_list, password, _length):
</span></span><span style="display:flex;"><span>    sb <span style="color:#f92672">=</span> [bytearray(<span style="color:#ae81ff">8</span>) <span style="color:#66d9ef">for</span> _x_ <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">32</span>)]
</span></span><span style="display:flex;"><span>    rcx <span style="color:#f92672">=</span> oi <span style="color:#f92672">=</span> i <span style="color:#f92672">=</span> loop <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    password_indexes <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    subloop <span style="color:#f92672">=</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> i <span style="color:#f92672">&lt;=</span> _length:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#print_zone(sb, rcx)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#print()</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span>:
</span></span><span style="display:flex;"><span>            v <span style="color:#f92672">=</span> _list[i][<span style="color:#ae81ff">3</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">Exception</span>:
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">&#34;No more instructions!&#34;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> password_indexes
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> v:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0x00</span>: <span style="color:#75715e"># gets size of user input</span>
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>loop<span style="color:#e6db74">}</span><span style="color:#e6db74"> [FN 0x00]: size of input calculated</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">RCX = </span><span style="color:#e6db74">{</span>rcx<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>                sb[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> bytearray(len(password)<span style="color:#f92672">.</span>to_bytes(<span style="color:#ae81ff">8</span>, <span style="color:#e6db74">&#34;big&#34;</span>))
</span></span><span style="display:flex;"><span>                i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0x01</span>: <span style="color:#75715e"># shl</span>
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>loop<span style="color:#e6db74">}</span><span style="color:#e6db74"> [FN 0x01]: &#34;</span>, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>)
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;0x</span><span style="color:#e6db74">{</span>int<span style="color:#f92672">.</span>from_bytes(sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>], <span style="color:#e6db74">&#39;big&#39;</span>)<span style="color:#e6db74">:</span><span style="color:#e6db74">016X</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> &lt;&lt; 0x</span><span style="color:#e6db74">{</span>int<span style="color:#f92672">.</span>from_bytes(sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], <span style="color:#e6db74">&#39;big&#39;</span>)<span style="color:#e6db74">:</span><span style="color:#e6db74">02x</span><span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>                sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> bytearray(int((int<span style="color:#f92672">.</span>from_bytes(sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>], <span style="color:#e6db74">&#34;big&#34;</span>) <span style="color:#f92672">&lt;&lt;</span> int<span style="color:#f92672">.</span>from_bytes(sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], <span style="color:#e6db74">&#34;big&#34;</span>)) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xffffffff</span>)<span style="color:#f92672">.</span>to_bytes(<span style="color:#ae81ff">8</span>, <span style="color:#e6db74">&#34;big&#34;</span>))
</span></span><span style="display:flex;"><span>                rcx <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0x02</span>: <span style="color:#75715e"># modulus</span>
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>loop<span style="color:#e6db74">}</span><span style="color:#e6db74"> [FN 0x02]: &#34;</span>, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>)
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;0x</span><span style="color:#e6db74">{</span>int<span style="color:#f92672">.</span>from_bytes(sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>], <span style="color:#e6db74">&#39;big&#39;</span>)<span style="color:#e6db74">:</span><span style="color:#e6db74">016X</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> % 0x</span><span style="color:#e6db74">{</span>int<span style="color:#f92672">.</span>from_bytes(sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], <span style="color:#e6db74">&#39;big&#39;</span>)<span style="color:#e6db74">:</span><span style="color:#e6db74">02x</span><span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>                sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>][<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>][<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">%</span> sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>                rcx <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0x03</span>: <span style="color:#75715e"># userinput</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># to simulate what the vm is doing, lets set ba[0] to a &#34;ptr&#34;</span>
</span></span><span style="display:flex;"><span>                sb[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> bytearray(int(<span style="color:#ae81ff">0x000055555555c860</span>)<span style="color:#f92672">.</span>to_bytes(<span style="color:#ae81ff">8</span>, <span style="color:#e6db74">&#34;big&#34;</span>))
</span></span><span style="display:flex;"><span>                rcx <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0x04</span>: <span style="color:#75715e"># idiv</span>
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>loop<span style="color:#e6db74">}</span><span style="color:#e6db74"> [FN 0x04]: &#34;</span>, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>)
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;0x</span><span style="color:#e6db74">{</span>int<span style="color:#f92672">.</span>from_bytes(sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>], <span style="color:#e6db74">&#39;big&#39;</span>)<span style="color:#e6db74">:</span><span style="color:#e6db74">016X</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> / 0x</span><span style="color:#e6db74">{</span>int<span style="color:#f92672">.</span>from_bytes(sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], <span style="color:#e6db74">&#39;big&#39;</span>)<span style="color:#e6db74">:</span><span style="color:#e6db74">02x</span><span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>                sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> bytearray(idiv_func(int<span style="color:#f92672">.</span>from_bytes(sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>], <span style="color:#e6db74">&#34;big&#34;</span>), int<span style="color:#f92672">.</span>from_bytes(sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], <span style="color:#e6db74">&#34;big&#34;</span>))<span style="color:#f92672">.</span>to_bytes(<span style="color:#ae81ff">8</span>, <span style="color:#e6db74">&#34;big&#34;</span>))
</span></span><span style="display:flex;"><span>                rcx <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0x05</span>: <span style="color:#75715e"># add</span>
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>loop<span style="color:#e6db74">}</span><span style="color:#e6db74"> [FN 0x05]: &#34;</span>, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>)
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;0x</span><span style="color:#e6db74">{</span>int<span style="color:#f92672">.</span>from_bytes(sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>], <span style="color:#e6db74">&#39;big&#39;</span>)<span style="color:#e6db74">:</span><span style="color:#e6db74">016X</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> + 0x</span><span style="color:#e6db74">{</span>int<span style="color:#f92672">.</span>from_bytes(sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], <span style="color:#e6db74">&#39;big&#39;</span>)<span style="color:#e6db74">:</span><span style="color:#e6db74">02x</span><span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>                sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> bytearray((int<span style="color:#f92672">.</span>from_bytes(sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>], <span style="color:#e6db74">&#34;big&#34;</span>)<span style="color:#f92672">+</span>int<span style="color:#f92672">.</span>from_bytes(sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], <span style="color:#e6db74">&#34;big&#34;</span>))<span style="color:#f92672">.</span>to_bytes(<span style="color:#ae81ff">8</span>, <span style="color:#e6db74">&#34;big&#34;</span>))
</span></span><span style="display:flex;"><span>                rcx <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0x06</span>: <span style="color:#75715e"># imul</span>
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>loop<span style="color:#e6db74">}</span><span style="color:#e6db74"> [FN 0x05]: &#34;</span>, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>)
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;0x</span><span style="color:#e6db74">{</span>int<span style="color:#f92672">.</span>from_bytes(sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>], <span style="color:#e6db74">&#39;big&#39;</span>)<span style="color:#e6db74">:</span><span style="color:#e6db74">016X</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> * 0x</span><span style="color:#e6db74">{</span>int<span style="color:#f92672">.</span>from_bytes(sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], <span style="color:#e6db74">&#39;big&#39;</span>)<span style="color:#e6db74">:</span><span style="color:#e6db74">02x</span><span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>                sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> bytearray(imul_func(int<span style="color:#f92672">.</span>from_bytes(sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>], <span style="color:#e6db74">&#34;big&#34;</span>), int<span style="color:#f92672">.</span>from_bytes(sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], <span style="color:#e6db74">&#34;big&#34;</span>))<span style="color:#f92672">.</span>to_bytes(<span style="color:#ae81ff">8</span>, <span style="color:#e6db74">&#34;big&#34;</span>))
</span></span><span style="display:flex;"><span>                rcx <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0x07</span>: <span style="color:#75715e"># ptrace wrapper</span>
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>loop<span style="color:#e6db74">}</span><span style="color:#e6db74"> [FN 0x07]: </span><span style="color:#e6db74">{</span>colors<span style="color:#f92672">.</span>WARNING<span style="color:#e6db74">}</span><span style="color:#e6db74">ptrace() call</span><span style="color:#e6db74">{</span>colors<span style="color:#f92672">.</span>ENDC<span style="color:#e6db74">}</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">RCX = </span><span style="color:#e6db74">{</span>rcx<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>                i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0x08</span>:
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>loop<span style="color:#e6db74">}</span><span style="color:#e6db74"> [FN 0x08]: 0x08</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">RCX = </span><span style="color:#e6db74">{</span>rcx<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>                sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> bytearray(int(int<span style="color:#f92672">.</span>from_bytes(sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>], <span style="color:#e6db74">&#34;big&#34;</span>)<span style="color:#f92672">|</span>int<span style="color:#f92672">.</span>from_bytes(sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], <span style="color:#e6db74">&#34;big&#34;</span>))<span style="color:#f92672">.</span>to_bytes(<span style="color:#ae81ff">8</span>, <span style="color:#e6db74">&#34;big&#34;</span>))
</span></span><span style="display:flex;"><span>                rcx <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0x09</span>: <span style="color:#75715e"># more math</span>
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>loop<span style="color:#e6db74">}</span><span style="color:#e6db74"> [FN 0x09]: silly maths</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">RCX = </span><span style="color:#e6db74">{</span>rcx<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>                    rax <span style="color:#f92672">=</span> (sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">8</span>) <span style="color:#f92672">+</span> sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>                    rax <span style="color:#f92672">+=</span> <span style="color:#ae81ff">0x11</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                    rax <span style="color:#f92672">=</span> sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x11</span>
</span></span><span style="display:flex;"><span>                _rcx <span style="color:#f92672">=</span> rax
</span></span><span style="display:flex;"><span>                rdx <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x5555555555555556</span>
</span></span><span style="display:flex;"><span>                rdx <span style="color:#f92672">=</span> (rdx <span style="color:#f92672">*</span> rax) <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">64</span>
</span></span><span style="display:flex;"><span>                rax <span style="color:#f92672">=</span> rax <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">0x3f</span>
</span></span><span style="display:flex;"><span>                rdx <span style="color:#f92672">-=</span> rax
</span></span><span style="display:flex;"><span>                rax <span style="color:#f92672">=</span> rdx<span style="color:#f92672">+</span>rdx<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>                sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> _rcx <span style="color:#f92672">-</span> rax
</span></span><span style="display:flex;"><span>                i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0x0a</span>: <span style="color:#75715e"># print_chk, free</span>
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>loop<span style="color:#e6db74">}</span><span style="color:#e6db74"> [FN 0x0a]: print</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">RCX = </span><span style="color:#e6db74">{</span>rcx<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>                _out <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span> vv <span style="color:#f92672">in</span> sb:
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> vv[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0x0</span> <span style="color:#f92672">and</span> vv[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0x0a</span>:
</span></span><span style="display:flex;"><span>                        _out <span style="color:#f92672">+=</span> chr(vv[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>colors<span style="color:#f92672">.</span>OKGREEN<span style="color:#e6db74">}</span><span style="color:#e6db74">[TXT]: </span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">{</span>_out<span style="color:#e6db74">}</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">{</span>colors<span style="color:#f92672">.</span>ENDC<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>                rcx <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0x0b</span>: <span style="color:#75715e"># jmp</span>
</span></span><span style="display:flex;"><span>                s <span style="color:#f92672">=</span> _list[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">3</span>]
</span></span><span style="display:flex;"><span>                i <span style="color:#f92672">+=</span> s<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>loop<span style="color:#e6db74">}</span><span style="color:#e6db74"> [FN 0x0b]: jmp $rip+</span><span style="color:#e6db74">{</span>hex(s)<span style="color:#e6db74">}</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">RCX = </span><span style="color:#e6db74">{</span>rcx<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0x0c</span>: <span style="color:#75715e"># math</span>
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>loop<span style="color:#e6db74">}</span><span style="color:#e6db74"> [FN 0x0c]: silly maths</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">RCX = </span><span style="color:#e6db74">{</span>rcx<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>                rax <span style="color:#f92672">=</span> sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>                rax <span style="color:#f92672">=</span> rax<span style="color:#f92672">+</span>rax<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span><span style="color:#f92672">-</span><span style="color:#ae81ff">0x06</span>
</span></span><span style="display:flex;"><span>                rax <span style="color:#f92672">+=</span> rax
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> rax <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0xff</span>:
</span></span><span style="display:flex;"><span>                    sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> rax <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xff</span>
</span></span><span style="display:flex;"><span>                    sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> rax <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                    sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> rax
</span></span><span style="display:flex;"><span>                i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0x0d</span>: <span style="color:#75715e"># looping over password</span>
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>loop<span style="color:#e6db74">}</span><span style="color:#e6db74"> [FN 0x0d]: password loop</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">RCX = </span><span style="color:#e6db74">{</span>rcx<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>                rcx <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0x0e</span>: <span style="color:#75715e"># zero out chunk</span>
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>loop<span style="color:#e6db74">}</span><span style="color:#e6db74"> [FN 0x0e]: zero out chunk</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">RCX = </span><span style="color:#e6db74">{</span>rcx<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>                sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> bytearray((<span style="color:#ae81ff">0</span>)<span style="color:#f92672">.</span>to_bytes(<span style="color:#ae81ff">8</span>, <span style="color:#e6db74">&#34;big&#34;</span>))
</span></span><span style="display:flex;"><span>                rcx <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0x0f</span>: <span style="color:#75715e"># malloc to prep for user input</span>
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>loop<span style="color:#e6db74">}</span><span style="color:#e6db74"> [FN 0x0f]: prep for user input</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">RCX = </span><span style="color:#e6db74">{</span>rcx<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>                rcx <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0x10</span>: <span style="color:#75715e"># copy one 8 byte chunk to another</span>
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>loop<span style="color:#e6db74">}</span><span style="color:#e6db74"> [FN 0x10]: </span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">RCX = </span><span style="color:#e6db74">{</span>rcx<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>                _val <span style="color:#f92672">=</span> _list[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">3</span>]
</span></span><span style="display:flex;"><span>                _rcx <span style="color:#f92672">=</span> rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">0x1</span>
</span></span><span style="display:flex;"><span>                _rcx <span style="color:#f92672">-=</span> _val
</span></span><span style="display:flex;"><span>                sb[rcx] <span style="color:#f92672">=</span> sb[_rcx] <span style="color:#75715e">#check</span>
</span></span><span style="display:flex;"><span>                rcx <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0x11</span>: <span style="color:#75715e"># internal loop, ensure this works</span>
</span></span><span style="display:flex;"><span>                subloop <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>                oi <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>                _st <span style="color:#f92672">=</span> _list[i<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>][<span style="color:#ae81ff">3</span>]
</span></span><span style="display:flex;"><span>                jmp_cond <span style="color:#f92672">=</span> _list[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">3</span>] <span style="color:#f92672">+</span> (_list[i<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">8</span>) <span style="color:#75715e"># sry</span>
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>loop<span style="color:#e6db74">}</span><span style="color:#e6db74"> [FN 0x11]: next = </span><span style="color:#e6db74">{</span>hex(jmp_cond)<span style="color:#e6db74">}</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">RCX = </span><span style="color:#e6db74">{</span>rcx<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>                i <span style="color:#f92672">=</span> jmp_cond
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0x12</span>: <span style="color:#75715e"># grab random char from user input</span>
</span></span><span style="display:flex;"><span>                _loc <span style="color:#f92672">=</span> _list[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">3</span>]
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>loop<span style="color:#e6db74">}</span><span style="color:#e6db74"> [FN 0x12] password[</span><span style="color:#e6db74">{</span>_loc<span style="color:#e6db74">}</span><span style="color:#e6db74">]: </span><span style="color:#e6db74">{</span>chr(password[_loc])<span style="color:#e6db74">}</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">RCX = </span><span style="color:#e6db74">{</span>rcx<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>                password_indexes<span style="color:#f92672">.</span>append(_loc)
</span></span><span style="display:flex;"><span>                _val <span style="color:#f92672">=</span> password[_loc]
</span></span><span style="display:flex;"><span>                sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> bytearray(int(_val)<span style="color:#f92672">.</span>to_bytes(<span style="color:#ae81ff">8</span>, <span style="color:#e6db74">&#34;big&#34;</span>))
</span></span><span style="display:flex;"><span>                i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0x13</span>: <span style="color:#75715e"># compare computed sizes</span>
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>loop<span style="color:#e6db74">}</span><span style="color:#e6db74"> [FN 0x13]: &#34;</span>, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>)
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;0x</span><span style="color:#e6db74">{</span>int<span style="color:#f92672">.</span>from_bytes(sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>], <span style="color:#e6db74">&#39;big&#39;</span>)<span style="color:#e6db74">:</span><span style="color:#e6db74">016X</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> == 0x</span><span style="color:#e6db74">{</span>int<span style="color:#f92672">.</span>from_bytes(sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], <span style="color:#e6db74">&#39;big&#39;</span>)<span style="color:#e6db74">:</span><span style="color:#e6db74">02x</span><span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>] <span style="color:#f92672">==</span> sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]:
</span></span><span style="display:flex;"><span>                    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>colors<span style="color:#f92672">.</span>OKGREEN<span style="color:#e6db74">}</span><span style="color:#e6db74">true</span><span style="color:#e6db74">{</span>colors<span style="color:#f92672">.</span>ENDC<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>                    sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> bytearray((<span style="color:#ae81ff">1</span>)<span style="color:#f92672">.</span>to_bytes(<span style="color:#ae81ff">8</span>, <span style="color:#e6db74">&#34;big&#34;</span>))
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>colors<span style="color:#f92672">.</span>FAIL<span style="color:#e6db74">}</span><span style="color:#e6db74">false</span><span style="color:#e6db74">{</span>colors<span style="color:#f92672">.</span>ENDC<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>                    sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> bytearray((<span style="color:#ae81ff">0</span>)<span style="color:#f92672">.</span>to_bytes(<span style="color:#ae81ff">8</span>, <span style="color:#e6db74">&#34;big&#34;</span>))
</span></span><span style="display:flex;"><span>                rcx <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0x14</span>:
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>colors<span style="color:#f92672">.</span>FAIL<span style="color:#e6db74">}</span><span style="color:#e6db74">! [FN 0x14] !</span><span style="color:#e6db74">{</span>colors<span style="color:#f92672">.</span>ENDC<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>                rcx <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0x15</span>: <span style="color:#75715e"># math, this might need to be fixed idk</span>
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>loop<span style="color:#e6db74">}</span><span style="color:#e6db74"> [FN 0x15]: silly maths</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">RCX = </span><span style="color:#e6db74">{</span>rcx<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>                rdx <span style="color:#f92672">=</span> sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>                rdx <span style="color:#f92672">=</span> (rdx <span style="color:#f92672">*</span> <span style="color:#ae81ff">8</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x18</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> rdx <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0xff</span>:
</span></span><span style="display:flex;"><span>                    sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> rdx <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xff</span>
</span></span><span style="display:flex;"><span>                    sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> rdx <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                    sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> rdx
</span></span><span style="display:flex;"><span>                i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0x16</span>: <span style="color:#75715e"># check compare result, jmp accordingly</span>
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>loop<span style="color:#e6db74">}</span><span style="color:#e6db74"> [FN 0x16]: &#34;</span>, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>)
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;0x</span><span style="color:#e6db74">{</span>int<span style="color:#f92672">.</span>from_bytes(sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], <span style="color:#e6db74">&#39;big&#39;</span>)<span style="color:#e6db74">:</span><span style="color:#e6db74">016x</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> &amp; 0x</span><span style="color:#e6db74">{</span>int<span style="color:#f92672">.</span>from_bytes(sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], <span style="color:#e6db74">&#39;big&#39;</span>)<span style="color:#e6db74">:</span><span style="color:#e6db74">02x</span><span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>                _tmp <span style="color:#f92672">=</span> int<span style="color:#f92672">.</span>from_bytes(sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], <span style="color:#e6db74">&#34;big&#34;</span>)
</span></span><span style="display:flex;"><span>                _tmp <span style="color:#f92672">=</span> _tmp <span style="color:#f92672">&amp;</span> _tmp
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> _tmp <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>                    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;adding </span><span style="color:#e6db74">{</span>_list[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">3</span>]<span style="color:#e6db74">}</span><span style="color:#e6db74"> to instruction pointer&#34;</span>)
</span></span><span style="display:flex;"><span>                    i <span style="color:#f92672">+=</span> int<span style="color:#f92672">.</span>from_bytes(_list[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>], <span style="color:#e6db74">&#34;big&#34;</span>)
</span></span><span style="display:flex;"><span>                i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>                rcx <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0x17</span>: <span style="color:#75715e"># relative move</span>
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>loop<span style="color:#e6db74">}</span><span style="color:#e6db74"> [FN 0x17]: mov sb[</span><span style="color:#e6db74">{</span>rcx<span style="color:#e6db74">}</span><span style="color:#e6db74">], 0x</span><span style="color:#e6db74">{</span>int<span style="color:#f92672">.</span>from_bytes(sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], <span style="color:#e6db74">&#39;big&#39;</span>)<span style="color:#e6db74">:</span><span style="color:#e6db74">016x</span><span style="color:#e6db74">}</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">RCX = </span><span style="color:#e6db74">{</span>rcx<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>                sb[rcx] <span style="color:#f92672">=</span> bytearray(int<span style="color:#f92672">.</span>from_bytes(sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], <span style="color:#e6db74">&#34;big&#34;</span>)<span style="color:#f92672">.</span>to_bytes(<span style="color:#ae81ff">8</span>, <span style="color:#e6db74">&#34;big&#34;</span>))
</span></span><span style="display:flex;"><span>                rcx <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0x18</span>: <span style="color:#75715e"># sub</span>
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>loop<span style="color:#e6db74">}</span><span style="color:#e6db74"> [FN 0x18]: &#34;</span>, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>)
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;0x</span><span style="color:#e6db74">{</span>int<span style="color:#f92672">.</span>from_bytes(sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>], <span style="color:#e6db74">&#39;big&#39;</span>)<span style="color:#e6db74">:</span><span style="color:#e6db74">016X</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> -= 0x</span><span style="color:#e6db74">{</span>int<span style="color:#f92672">.</span>from_bytes(sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], <span style="color:#e6db74">&#39;big&#39;</span>)<span style="color:#e6db74">:</span><span style="color:#e6db74">02x</span><span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span>:
</span></span><span style="display:flex;"><span>                    sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> bytearray((int<span style="color:#f92672">.</span>from_bytes(sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>], <span style="color:#e6db74">&#34;big&#34;</span>) <span style="color:#f92672">-</span> int<span style="color:#f92672">.</span>from_bytes(sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], <span style="color:#e6db74">&#34;big&#34;</span>) <span style="color:#f92672">&amp;</span> (<span style="color:#ae81ff">4</span><span style="color:#f92672">**</span><span style="color:#ae81ff">32</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>))<span style="color:#f92672">.</span>to_bytes(<span style="color:#ae81ff">8</span>, <span style="color:#e6db74">&#34;big&#34;</span>))
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">Exception</span> <span style="color:#66d9ef">as</span> e:
</span></span><span style="display:flex;"><span>                    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>colors<span style="color:#f92672">.</span>FAIL<span style="color:#e6db74">}</span><span style="color:#e6db74">[!] </span><span style="color:#e6db74">{</span>e<span style="color:#e6db74">}{</span>colors<span style="color:#f92672">.</span>ENDC<span style="color:#e6db74">}</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">Exiting..</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>                    print(sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>], sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>                    exit(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>                rcx <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0x19</span>: <span style="color:#75715e"># immediate move</span>
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>loop<span style="color:#e6db74">}</span><span style="color:#e6db74"> [FN 0x19]: imm sb[</span><span style="color:#e6db74">{</span>rcx<span style="color:#e6db74">}</span><span style="color:#e6db74">], </span><span style="color:#e6db74">{</span>hex(_list[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">3</span>] <span style="color:#f92672">+</span> (_list[i<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">8</span>) <span style="color:#f92672">+</span> (_list[i<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">16</span>))<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>                sb[rcx] <span style="color:#f92672">=</span> bytearray((_list[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">3</span>] <span style="color:#f92672">+</span> (_list[i<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">8</span>) <span style="color:#f92672">+</span> (_list[i<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">16</span>))<span style="color:#f92672">.</span>to_bytes(<span style="color:#ae81ff">8</span>, <span style="color:#e6db74">&#34;big&#34;</span>))
</span></span><span style="display:flex;"><span>                rcx <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0x1a</span>: <span style="color:#75715e">#shr</span>
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>loop<span style="color:#e6db74">}</span><span style="color:#e6db74"> [FN 0x1a] &#34;</span>, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>)
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;0x</span><span style="color:#e6db74">{</span>int<span style="color:#f92672">.</span>from_bytes(sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>], <span style="color:#e6db74">&#39;big&#39;</span>)<span style="color:#e6db74">:</span><span style="color:#e6db74">016X</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> &gt;&gt; 0x</span><span style="color:#e6db74">{</span>int<span style="color:#f92672">.</span>from_bytes(sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], <span style="color:#e6db74">&#39;big&#39;</span>)<span style="color:#e6db74">:</span><span style="color:#e6db74">02x</span><span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>                sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> bytearray(int((int<span style="color:#f92672">.</span>from_bytes(sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>], <span style="color:#e6db74">&#34;big&#34;</span>) <span style="color:#f92672">&gt;&gt;</span> int<span style="color:#f92672">.</span>from_bytes(sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], <span style="color:#e6db74">&#34;big&#34;</span>)) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xffffffff</span>)<span style="color:#f92672">.</span>to_bytes(<span style="color:#ae81ff">8</span>, <span style="color:#e6db74">&#34;big&#34;</span>))
</span></span><span style="display:flex;"><span>                rcx <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0x1c</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> subloop:
</span></span><span style="display:flex;"><span>                    _val <span style="color:#f92672">=</span> sb[rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>                    _rcx <span style="color:#f92672">=</span> rcx <span style="color:#f92672">-</span> _st <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                    sb[_rcx] <span style="color:#f92672">=</span> bytearray(int<span style="color:#f92672">.</span>from_bytes(_val, <span style="color:#e6db74">&#34;big&#34;</span>)<span style="color:#f92672">.</span>to_bytes(<span style="color:#ae81ff">8</span>, <span style="color:#e6db74">&#34;big&#34;</span>))
</span></span><span style="display:flex;"><span>                    rcx <span style="color:#f92672">-=</span> _st
</span></span><span style="display:flex;"><span>                    i <span style="color:#f92672">=</span> oi
</span></span><span style="display:flex;"><span>                    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>loop<span style="color:#e6db74">}</span><span style="color:#e6db74"> [FN 0x1c] restore ip</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">RCX = </span><span style="color:#e6db74">{</span>rcx<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>                    subloop <span style="color:#f92672">=</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>loop<span style="color:#e6db74">}</span><span style="color:#e6db74"> [FN 0x1c] EXIT&#34;</span>)
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span> password_indexes
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> _:
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>colors<span style="color:#f92672">.</span>FAIL<span style="color:#e6db74">}</span><span style="color:#e6db74">Hit an invalid instruction!!! [</span><span style="color:#e6db74">{</span>hex(v)<span style="color:#e6db74">}</span><span style="color:#e6db74">]</span><span style="color:#e6db74">{</span>colors<span style="color:#f92672">.</span>ENDC<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>                exit()
</span></span><span style="display:flex;"><span>        loop <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#print_zone(sb, rcx)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#print()</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">print_zone</span>(zone, rcx, i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> i <span style="color:#f92672">&lt;</span> len(zone):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> i <span style="color:#f92672">==</span> rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>:
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>colors<span style="color:#f92672">.</span>OKCYAN<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">elif</span> i <span style="color:#f92672">==</span> rcx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>colors<span style="color:#f92672">.</span>OKGREEN<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> i <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> i <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;0x</span><span style="color:#e6db74">{</span>int<span style="color:#f92672">.</span>from_bytes(zone[i], <span style="color:#e6db74">&#39;big&#39;</span>)<span style="color:#e6db74">:</span><span style="color:#e6db74">016x</span><span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;0x</span><span style="color:#e6db74">{</span>int<span style="color:#f92672">.</span>from_bytes(zone[i], <span style="color:#e6db74">&#39;big&#39;</span>)<span style="color:#e6db74">:</span><span style="color:#e6db74">016x</span><span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>colors<span style="color:#f92672">.</span>ENDC<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>)
</span></span><span style="display:flex;"><span>        i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">imul_func</span>(a, b):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> int(a <span style="color:#f92672">*</span> b)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">idiv_func</span>(a, b):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> int(a <span style="color:#f92672">/</span> b)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">split_instructions</span>():
</span></span><span style="display:flex;"><span>    count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    split_inst <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    cur <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> v <span style="color:#f92672">in</span> instructions:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> count <span style="color:#f92672">%</span> <span style="color:#ae81ff">4</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> count <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>            split_inst<span style="color:#f92672">.</span>append(cur)
</span></span><span style="display:flex;"><span>            cur <span style="color:#f92672">=</span> v<span style="color:#f92672">.</span>to_bytes(<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;little&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            cur <span style="color:#f92672">+=</span> v<span style="color:#f92672">.</span>to_bytes(<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;little&#34;</span>)
</span></span><span style="display:flex;"><span>        count <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> split_inst
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">more_fun</span>(pw_index, password):
</span></span><span style="display:flex;"><span>    pwd <span style="color:#f92672">=</span> [bytearray(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">8</span>) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">8</span>)]
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;pw_index&#34;</span>)
</span></span><span style="display:flex;"><span>    print(pw_index)
</span></span><span style="display:flex;"><span>    c <span style="color:#f92672">=</span> d <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, len(pw_index)):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> i <span style="color:#f92672">%</span> <span style="color:#ae81ff">4</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> i <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>            pwd[c][<span style="color:#f92672">~</span>d] <span style="color:#f92672">=</span> password[pw_index[i]]
</span></span><span style="display:flex;"><span>            d <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            c <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            d <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>            pwd[c][<span style="color:#f92672">~</span>d] <span style="color:#f92672">=</span> password[pw_index[i]]
</span></span><span style="display:flex;"><span>            d <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">[+] initial sorted password chunks&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> v <span style="color:#f92672">in</span> pwd:
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;0x</span><span style="color:#e6db74">{</span>int<span style="color:#f92672">.</span>from_bytes(v, <span style="color:#e6db74">&#39;big&#39;</span>)<span style="color:#e6db74">:</span><span style="color:#e6db74">016x</span><span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    andv <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span><span style="color:#f92672">**</span><span style="color:#ae81ff">16</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">7</span>, <span style="color:#f92672">~</span><span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>        a <span style="color:#f92672">=</span> int<span style="color:#f92672">.</span>from_bytes(pwd[i], <span style="color:#e6db74">&#34;big&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> i:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">7</span>:
</span></span><span style="display:flex;"><span>                [redacted]
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">6</span>:
</span></span><span style="display:flex;"><span>                [redacted]
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">5</span>:
</span></span><span style="display:flex;"><span>                [redacted]
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">4</span>:
</span></span><span style="display:flex;"><span>                [redacted]
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">3</span>:
</span></span><span style="display:flex;"><span>                [redacted]
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">2</span>:
</span></span><span style="display:flex;"><span>                [redacted]
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>                [redacted]
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>                [redacted]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;chunk </span><span style="color:#e6db74">{</span>i<span style="color:#e6db74">}</span><span style="color:#e6db74">: 0x</span><span style="color:#e6db74">{</span>z <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">4</span><span style="color:#f92672">**</span><span style="color:#ae81ff">32</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#e6db74">:</span><span style="color:#e6db74">016x</span><span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (z <span style="color:#f92672">&amp;</span> z) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>colors<span style="color:#f92672">.</span>OKGREEN<span style="color:#e6db74">}</span><span style="color:#e6db74">match</span><span style="color:#e6db74">{</span>colors<span style="color:#f92672">.</span>ENDC<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>colors<span style="color:#f92672">.</span>FAIL<span style="color:#e6db74">}</span><span style="color:#e6db74">!match</span><span style="color:#e6db74">{</span>colors<span style="color:#f92672">.</span>ENDC<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">gen_password</span>(pw_index):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># add yourself!</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pass</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">runner</span>(password):
</span></span><span style="display:flex;"><span>    _list <span style="color:#f92672">=</span> split_instructions()
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#print(_list)</span>
</span></span><span style="display:flex;"><span>    pw_index <span style="color:#f92672">=</span> parser(_list, password, len(_list))
</span></span><span style="display:flex;"><span>    more_fun(pw_index, password)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#gen_password(pw_index)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">main</span>():
</span></span><span style="display:flex;"><span>    runner(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;__main__&#34;</span>:
</span></span><span style="display:flex;"><span>    main()
</span></span></code></pre></div><h4 id="analysisgdb">analysis.gdb<a hidden class="anchor" aria-hidden="true" href="#analysisgdb">#</a></h4>
<pre tabindex="0"><code>set pagination off
set confirm off

starti
display/x $rax
display/x $rdi
display/x $rsi
display/x $rdx
display/x $rcx
display/x $r8
display/x $r9
display/x $rsp
display/x $rbp
display/10i $rip

set $str=0x55555555a3a0
set $ins=0x7fffffffdea0
set $analysisBp = 400

# break at call to execution loop
break *$base+0x1198
c

# ptrace break
break *$base+0x13f7
commands
set $rax=0x0
c
end

# break at each iteration of loop to identify which function is called
set $loop=0
break *$base+0x2908
commands
silent
printf &#34;loop: %d\n&#34;, $loop
printf &#34;call qword ptr [R8+R9*0x8] = 0x%llx\n&#34;, $r8+($r9*8)
printf &#34;function = 0x%llx\n&#34;, *(long *)($r8+($r9*8))
printf &#34;[func] = 0x%lx\n&#34;, $r9
printf &#34;rcx = 0x%lx\n&#34;, *(long *)$rcx
printf &#34;inst: 0x%lx\n\n&#34;, *(long *)$ins
set $loop=$loop+1
if $loop &lt;= $analysisBp
c
end
end

# break inside of 0x11 function loop
break *0x00007ffff7fb6069
commands
printf &#34;loop: %d\n&#34;, $loop
printf &#34;[func] = 0x%lx\n&#34;, $r9
printf &#34;rcx = 0x%lx\n&#34;, *(long *)$rcx
set $loop=$loop+1
end

# start
c
</code></pre>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>

<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share [HTB] vvm on x"
            href="https://x.com/intent/tweet/?text=%5bHTB%5d%20vvm&amp;url=https%3a%2f%2fyams.bot%2fwriteups%2fhackthebox%2fvvm%2f&amp;hashtags=">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share [HTB] vvm on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fyams.bot%2fwriteups%2fhackthebox%2fvvm%2f&amp;title=%5bHTB%5d%20vvm&amp;summary=%5bHTB%5d%20vvm&amp;source=https%3a%2f%2fyams.bot%2fwriteups%2fhackthebox%2fvvm%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://yams.bot/">üç† yamsbot</a></span> ¬∑ 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
